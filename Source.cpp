/*
Файл: Practica.cpp
Летняя практика №1 2021
Автор: Проценко Е.С.
Дата создания: 30.06.2021
Задача №35
*/
// подключение заголовочных файлов стандартных библиотек языка C
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <time.h>
//объявление констант(размерность массива)
#define N 900
//прототипы функций
/*
A[]-параметр функции, принимает массив чисел(целых).
Функция ничего не возвращает, она заполняет массив рандомными целыми числами в диапозоне от 100 до 999
*/
void randomgen(int A[]);
/*
Функция быстрой сортировки, ничего не возвращает.
а[]-параметр функции, принимает массив чисел(целых).
low-параметр функции, принимает целое число(нижняя граница).
high-параметр функции, принимает целое число(верхняя граница).
*/
void quicksort(int a[], int low, int high);
/*
Продолжение функции быстрой сортировки(разделение), возращает целое число(верхнюю границу).
а[]-параметр функции, принимает массив чисел(целых).
low-параметр функции, принимает целое число(нижняя граница).
high-параметр функции, принимает целое число(верхняя граница).
*/
int split(int a[], int low, int high);
int main()
{
	//смена языка в консоли
	setlocale(LC_ALL, "Rus");
	//Объявление переменных
	int A[N], AA[N]; //массивы целых чисел с размерностью N
	int n, p; // счетчики(n-выбор действия в switch; р-счетчик для вывода массива)
	int r, t, y, u; // счетчики(r-счетчик прохождения по массиву(0-899), t-весь диапозон чисел(100-999), y-счетчик вывода массива, u-количество элементов массива АА, которые нужно вывести) 
	//вызов функции(заполнение массива случайными числами)
	randomgen(A);
	printf("Вивести заповнений масив?\n1.Так\n2.Нi\n3.Hi(Вивести вiдсортований масив)\n");
	if ((scanf("%d", &n)) == 0)
	{
		printf("Такого варiанту немає");
		return 1;
	}
	if (n > 3 || n < 1)
	{
		printf("Такого варiанту немає");
		return 1;
	}
	switch (n)
	{
	case 1:
	{
		//цикл вывода массив
		for (p = 1; p <= N; p++)
		{
			printf("%d ", A[p - 1]);
			if (p % 30 == 0)
				printf("\n");
		}
		break;
	}
	case 2:
	{
		break;
	}
	case 3:
	{
		//вызов функции(быстрая сортировка(по возрастанию))
		quicksort(A, 0, N - 1);
		//вывод массива
		for (p = 1; p <= N; p++)
		{
			printf("%d ", A[p - 1]);
			if (p % 30 == 0)
				printf("\n");
		}
		break;
	}
	}
	//вызов функции(быстрая сортировка(по возрастанию))
	quicksort(A, 0, N - 1);
	//предложение вывести отсортированный массив, если в прошлый раз вы выбрали пункт 1 или 2
	if (n == 1 || n == 2)
	{
		printf("Вивести вiдсортований масив?\n1.Так\n2.Hi\n");
		if ((scanf("%d", &n)) == 0)
		{
			printf("Такого варiанту немає");
			return 1;
		}
		if (n > 2 || n < 1)
		{
			printf("Такого варiанту немає");
			return 1;
		}
		switch (n)
		{
		case 1:
		{
			for (p = 1; p <= N; p++)
			{
				printf("%d ", A[p - 1]);
				if (p % 30 == 0)
					printf("\n");
			}
			break;
		}
		case 2: {break; }
		}
	}
	printf("\n");
	r = 0;
	t = 100;
	y = 0;
	u = 0;
	/*
	Цикл для поиска недостающих чисел из диапозона 100-999 в массиве А и добавления их в массив АА.
	*/
	//цикл пройдется по каждому элементу массива
	while (r < N)
	{
		/*
		Если текущий элемент массива не равен t а также это не 0-й элемент массива,
		или текущий элемент массива не равен t а также предыдущий элемент тоже не ровнялся текущему t,
		тогда мы заносим текущее значение t в массив АА, увеличуем t на 1 а также количство элементов
		массива АА, которые нужно вывести увеличилось на 1. Выполняется снова проверка условия цикла
		*/
		if ((A[r] != t && r == 0) || (A[r] != t && A[r - 1] != t))
		{
			AA[y] = t;
			t++;
			y++;
			u++;
			continue;
		}
		// Если текущий элемент массива А равен t, переходим к следующему элементу массива, иначе увеличиваем t на 1
		if (A[r] == t)
			r++;
		else
			t++;
		if (r == N && t < 999)
		{
			while (t < 999)
			{
				t++;
				AA[y] = t;
				y++;
				u++;
			}
		}

	}
	// цикл для вывода нужного количества элементов массива АА
	for (y = 1; y <= u; y++)
	{
		printf("%d ", AA[y - 1]);
		if (y % 30 == 0)
			printf("\n");
	}
	//завершение работы
	return 0;
}
void randomgen(int A[])
{
	srand(time(0));
	for (int i = 0; i < N; i++)
	{
		A[i] = 100 + rand() % (999 - 100 + 1);
	}
}
void quicksort(int a[], int low, int high)
{
	int middle;
	if (low >= high) return;
	middle = split(a, low, high);
	quicksort(a, low, middle - 1);
	quicksort(a, middle + 1, high);
}
int split(int a[], int low, int high)
{
	int part_element = a[low];
	for (;;)
	{
		while (low < high && part_element <= a[high])
			high--;
		if (low >= high) break;
		a[low++] = a[high];
		while (low < high && a[low] <= part_element)
			low++;
		if (low >= high)break;
		a[high--] = a[low];
	}
	a[high] = part_element;
	return high;
}
